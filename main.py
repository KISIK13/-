import numpy as np #библиотека для точных математических расчетов
def sigmoid(x): #функция активации(сигмоида)
    return 1/(1+np.exp(-x)) 
def MSEfunc(Ytrue,Ypred): #функция расчета среднеквадратической ошибки
    return (Ytrue - Ypred)**2
training_inputs = np.array([[0,0,0,0], #входные данные для тренировки нейросети
                            [0,0,0,1],
                            [0,0,1,0],
                            [0,0,1,1],
                            [0,1,0,0],
                            [0,1,0,1],
                            [0,1,1,0],
                            [0,1,1,1],
                            [1,0,0,0],
                            [1,0,0,1],
                            [1,0,1,0],
                            [1,0,1,1],
                            [1,1,0,0],
                            [1,1,0,1],
                            [1,1,1,0],
                            [1,1,1,1]])
training_outputs = np.array([[0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0]]).T #выходные данные для тренировки нейросети
np.random.seed(312) #сид рандомизации
synaptic_weights = 2 * np.random.random((4,1)) - 1 #заполняем рандомными числами вес(4 штуки,т.к. 4 критерия)
for i in range(20000): #проводим 20000 тестов(для обучения нейросети)
    input_layer = training_inputs #входная последовательность
    outputs = sigmoid(np.dot(input_layer,synaptic_weights))#выходная последовательность(на текущий момент(с текущими весами))
    err = training_outputs - outputs #разность между предыдущим весом и текущим
    adjustments = np.dot(input_layer.T,err*(outputs*(1-outputs))) #высчитывание величины, для корректировки веса
    synaptic_weights += adjustments #корректировка веса
#обучение нейросети закончилось.Посчитаем среднеквадратическую ошибку
MSE_inputs = np.array([ [0,0,0,0], #введем начальные значения для подсчета
                        [0,0,0,1],
                        [0,0,1,0],
                        [0,0,1,1],
                        [0,1,0,0],
                        [0,1,0,1],
                        [0,1,1,0],
                        [0,1,1,1],
                        [1,0,0,0],
                        [1,0,0,1],
                        [1,0,1,0],
                        [1,0,1,1],
                        [1,1,0,0],
                        [1,1,0,1],
                        [1,1,1,0],
                        [1,1,1,1] ])

MSE = 0 #изначально ошибка равна 0
for i in range (16): #для всех 16 значений
    output = sigmoid(np.dot(MSE_inputs[i],synaptic_weights))#высчитываем предполагаемое значение
    print(i+1," тест: ")
    print("Истинное значение переменной: ",training_outputs[i]," Предполагаемое значение переменной: ",output," Итерационная ошибка: ",MSEfunc(training_outputs[i],output)/16 )
    MSE+=MSEfunc(training_outputs[i],output)/16 #накапливаем ошибку(путем вызова функции для подсчета ошибки в конкретный момент)
print("MSE=",MSE) #выводим на экран ошибку
new_input = np.array([1,1,1,1]) #инициализируем новые данные  
#далее идет заполнение данных
print("Введите 0,если хлебу более трех дней,иначе введите 1")
new_input[0] = input()
print("Введите 0,если на хлебе нет плесени,иначе введите 1")
new_input[1] = input()
print("Введите 0,если хлеб плохо пахнет,иначе введите 1")
new_input[2] = input()
print("Введите 0,если на хлебе нет хрустящей корочки,иначе введите 1")
new_input[3] = input()
#заполнение данных закончилось
output = sigmoid(np.dot(new_input,synaptic_weights))#высчитываем предполагаемое значение
print("Вывод нейросети:",output)#выводим результат
if output > 0.9:#обрабатываем результат
    print("Хлеб свежий")
else:
    print("Хлеб не свежий")


